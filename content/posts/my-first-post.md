---
title: "Setting up the Visual Studio Debugging path using CMake and Conan"
date: 2019-05-26T10:35:48+01:00
draft: false
---

When developing on Windows, chances are you have come across a variant of the following message when launching an executable for debugging on Visual Studio:

> The code execution cannot proceed because xxx.dll was not found. Reinstalling the program may fix this problem.

Often our first instict is to manually copy the missing DLLs into the same directory of our just-built executable. If the executable has many dependencies, you might find yourself doing this for every DLL file it complains about. Another alternative is to edit the project properties on Visual Studio, and modify the PATH environment variable when the application is launched for debugging. Both of these locations are valid as they follow the [standard DLL search order for desktop applications](https://docs.microsoft.com/en-us/windows/desktop/dlls/dynamic-link-library-search-order#standard-search-order-for-desktop-applications) on Windows.

Over time, neither of these two approaches is ideal. Consider the following scenario: CMake is used to generate Visual Studio projects, and a developer keeps using the same build directory that was initialized some time ago. One day, after a `git pull` (or equivalent) operation, our application now depends on a newer version of a DLL. This can be the cause of more obscure errors when launching the applications due to mismatching or missing symbols, because the DLLs that were copied manually for an earlier version may not have the same symbols or binary interface as the ones the application is now linked against. When working within a team, relying on manual modifications to the build environment is likely to lead to "works on my machine" issues.

Altering the project properties for a project generated by CMake is also only a temporary fix: the `.vcxproj` files are generated by CMake, and any changes that we make can be overwritten the next time the project is generated.

## Conan to the rescue
  
There are [a few different ways](https://blog.conan.io/2018/06/11/Transparent-CMake-Integration.html) of integrating Conan into a CMake project for dependency handling. Roughly, all of them involve the following:

- A `conanfile.txt` or `conanfile.py` that specifies the project's requirements
- A file created by one of the [CMake generators](https://docs.conan.io/en/latest/reference/generators.html), which is generated by calling `conan install`
- A `CMakeLists.txt` file that includes the files generated by the aforementioned step

If we inspect the Conan documentation, we can see that both the [`cmake`](https://docs.conan.io/en/latest/reference/generators/cmake.html) and [`cmake_multi`](https://docs.conan.io/en/latest/reference/generators/cmakemulti.html) declare CMake variables that contain a list to all "binary" folders for all dependencies:

* `CONAN_BIN_DIRS` when using the `cmake` generator
* `CONAN_BIN_DIRS_DEBUG` and `CONAN_BIN_DIRS_RELEASE` when using the `cmake_multi` generator

If the Conan recipes of the libraries listed as requirements follow the conventions recommended by Conan's documentation, the variables above will point exactly to the directories that contain the required DLLs. From the recipe's perspective, this involves either placing the DLLs in the `bin` subfolder inside the package, or by specifying which subfolder contains these files by setting the `cpp_info.bindirs` attribute in the `package_info()` method ([see documentation](https://docs.conan.io/en/latest/reference/conanfile/methods.html#package-info)). From my experience, all libraries available in [Conan Center](https://bintray.com/conan/conan-center) follow this convention.

## Setting the debugging environment from CMake

From the information above, we know that Conan provides us with the correct directories to set the `PATH` environment variable to. The next step is to get CMake to add that information to the Visual Studio projects it generates. Fortunately, we have ways of doing this, depending on the version of CMake we are using:

* In CMake >= 3.13 we should use the [`VS_DEBUGGER_ENVIRONMENT`](https://cmake.org/cmake/help/latest/prop_tgt/VS_DEBUGGER_ENVIRONMENT.html) target property. This property will directly set the local debugger environment for C++ targets.

For older versions of CMake, can can make use of Property Sheets to set project properties separate from the generated `.vcxproj` files. For this, we have two options:

* In CMake >= 3.8 we can use the [`VS_USER_PROPS`](https://todo) target property to assign the a custom property sheet to the generated `.vcxproj` files. With this approach, a `.props.user` file is generated in the CMake configuration stage, and assigned to the project using this target property.
* For older versions of CMake, we can create a `.vcxproj.user` file that sits alongside the project. 

Both of these approaches make use of a `.user` file, which is a legacy feature in Visual Studio that is no longer recommended for use. However, Visual Studio does take these files into consideration when working out the property hierarchy. 

## Putting it all together

```cmake
if(CMAKE_GENERATOR MATCHES "Visual Studio")
  include("${CMAKE_BINARY_DIR}/conanbuildinfo_multi.cmake")
else()
  include("${CMAKE_BINARY_DIR}/conanbuildinfo.cmake")
endif()

conan_basic_setup(TARGETS)

add_executable(HelloWorld hello_world.cpp)
target_link_libraries(HelloWorld PRIVATE CONAN_PKG::fmt)

set_target_properties(HelloWorld
                      PROPERTIES VS_DEBUGGER_ENVIRONMENT
                      "PATH=$<$<CONFIG:Debug>:${CONAN_BIN_DIRS_DEBUG}>"
                      "$<$<CONFIG:Release>:${CONAN_BIN_DIRS_RELEASE}>;%PATH%")
```

## Using the new CMake integration in Visual Studio
CMake is becoming more integrated into Visual Studio, and can now open CMake projects directly using the "Open Folder" feature. The examples above assume that we are using CMake with the Visual Studio generator (i.e., generating Visual Studio solution and project files). When opening a CMake project directly in Visual Studio 2019, Ninja is used as the default generator. 
...
